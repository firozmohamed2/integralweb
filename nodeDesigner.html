<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Node Designer</title>
    <!-- Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/reactflow/dist/style.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <style>
        body { font-family: 'Inter', sans-serif; }
        .react-flow__node { cursor: default; }
        .react-flow__handle { width: 8px; height: 8px; border-radius: 2px; border: 1px solid #111827; }
        .react-flow__attribution { display: none; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #111827; }
        ::-webkit-scrollbar-thumb { background: #374151; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #4b5563; }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 overflow-hidden">
    <div id="root"></div>

    <!-- Firebase (reuse config from index.html) -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDNqfRczOHTukGdXDnuzVXjbL7P5blnyAo",
            authDomain: "dbydx-ea226.firebaseapp.com",
            projectId: "dbydx-ea226",
            storageBucket: "dbydx-ea226.firebasestorage.app",
            messagingSenderId: "329650707379",
            appId: "1:329650707379:web:18bab2bab403e1004b89c6",
            measurementId: "G-2F7YVE2X94",
        };
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.firestore();
    </script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- React and dependencies via importmap (same pattern as designer2) -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom": "https://esm.sh/react-dom@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "reactflow": "https://esm.sh/reactflow@11.10.1?external=react,react-dom",
            "lucide-react": "https://esm.sh/lucide-react@0.263.1?external=react,react-dom",
            "react-hot-toast": "https://esm.sh/react-hot-toast@2.4.1?external=react,react-dom"
        }
    }
    </script>

    <script type="text/babel" data-type="module">
        import React, { useState, useCallback, useMemo, memo, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import ReactFlow, {
            ReactFlowProvider,
            addEdge,
            useNodesState,
            useEdgesState,
            Controls,
            Background,
            Handle,
            Position,
            useEdges,
            Panel
        } from 'reactflow';
        import {
            Video,
            HelpCircle,
            PlayCircle,
            Settings2,
            LogOut,
            Download,
            Code,
            Trash2,
            Copy,
            X,
            CheckCircle2,
            Circle,
            Eraser,
            RotateCcw,
            GripVertical,
            CheckCircle
        } from 'lucide-react';
        import toast, { Toaster } from 'react-hot-toast';

        // --- Types & Constants ---
        const NodeType = {
            PRIMARY_VIDEO: 'primaryVideo',
            POPUP_VIDEO: 'popupVideo',
            OPTIONS: 'options',
            ACTION: 'action',
        };

        const TriggerType = {
            AT_END: 'AT_END',
            AT_TIME: 'AT_TIME',
            ON_CORRECT: 'ON_CORRECT',
            ON_WRONG: 'ON_WRONG',
            ON_CLEAR: 'ON_CLEAR',
            ON_NOT_CLEAR: 'ON_NOT_CLEAR',
            DEFAULT: 'DEFAULT',
        };

        let nodeId = 1;
        const getNextId = () => `node_${nodeId++}`;

        // --- Utility: build JSON from graph ---
        const buildFlowJson = (nodes, edges, base = {}) => {
            const jsonNodes = nodes.map((node) => {
                const outgoingEdges = edges.filter((e) => e.source === node.id);
                const isMediaNode = node.type === NodeType.PRIMARY_VIDEO || node.type === NodeType.POPUP_VIDEO;
                const hasEndTrigger = outgoingEdges.some((edge) => edge.data?.trigger === TriggerType.AT_END);
                const isTerminal = isMediaNode ? !hasEndTrigger : outgoingEdges.length === 0;

                const events = outgoingEdges.map((edge) => ({
                    targetNodeId: edge.target,
                    trigger: edge.data?.trigger,
                    triggerTime: edge.data?.time,
                    label: edge.data?.label,
                }));

                return {
                    id: node.id,
                    type: node.type,
                    data: { ...node.data, isEndOfLesson: isTerminal },
                    meta: { isTerminal, nodeStatus: isTerminal ? 'TERMINAL_EXIT' : 'CONTINUES' },
                    events,
                };
            });

            return {
                flowId: base.flowId || (crypto.randomUUID ? crypto.randomUUID() : `flow_${Date.now()}`),
                createdAt: base.createdAt || new Date().toISOString(),
                nodes: jsonNodes,
                connections: edges.map((e) => ({ source: e.source, target: e.target, logic: e.data })),
            };
        };

        // --- Utility: build graph from JSON ---
        const buildGraphFromFlowJson = (json) => {
            if (!json || !Array.isArray(json.nodes)) return { nodes: [], edges: [] };

            const nodes = json.nodes.map((n) => ({
                id: n.id,
                type: n.type,
                position: { x: Math.random() * 500 + 100, y: Math.random() * 300 + 100 },
                data: n.data || {},
            }));

            const edges = (json.connections || []).map((c, index) => ({
                id: `e${c.source}-${c.target}-${index}`,
                source: c.source,
                target: c.target,
                data: c.logic || {},
                label: c.logic?.label || '',
                animated: true,
            }));

            return { nodes, edges };
        };

        // --- Custom Components (copied from designer2) ---
        const NodeWrapper = ({ selected, title, icon: Icon, colorClass, isTerminal, children }) => (
            <div
                className={`min-w-[240px] rounded-xl border-2 bg-gray-900 shadow-xl transition-all duration-200 relative ${
                    selected ? 'border-white shadow-indigo-500/20' : 'border-gray-700 hover:border-gray-600'
                }`}
            >
                {isTerminal && (
                    <div className="absolute -top-3 -right-2 bg-red-500 text-white text-[9px] font-bold px-2 py-0.5 rounded-full shadow-lg flex items-center gap-1 animate-pulse border border-gray-900 z-10 uppercase">
                        <LogOut size={10} /> End of Lesson
                    </div>
                )}
                <div className={`px-4 py-2 rounded-t-lg border-b border-gray-800 flex items-center gap-2 ${colorClass}`}>
                    <Icon size={16} className="text-white" />
                    <span className="font-semibold text-sm text-white">{title}</span>
                </div>
                <div className="p-4 space-y-2">{children}</div>
            </div>
        );

        const PrimaryVideoNode = memo(({ id, data, selected }) => {
            const edges = useEdges();
            const isTerminal = !edges.filter((e) => e.source === id).some((e) => e.data?.trigger === TriggerType.AT_END);
            return (
                <NodeWrapper selected={selected} title="Primary Video" icon={Video} colorClass="bg-indigo-600" isTerminal={isTerminal}>
                    <Handle type="target" position={Position.Top} className="!bg-indigo-500 !w-3 !h-3" />
                    <div className="text-xs text-gray-400">Video URL</div>
                    <div className="text-sm text-gray-200 truncate font-mono bg-gray-800 p-1.5 rounded border border-gray-700">
                        {data.url || 'No URL configured'}
                    </div>
                    <Handle type="source" position={Position.Bottom} className="!bg-indigo-500 !w-3 !h-3" />
                </NodeWrapper>
            );
        });

        const PopupVideoNode = memo(({ id, data, selected }) => {
            const edges = useEdges();
            const isTerminal = !edges.filter((e) => e.source === id).some((e) => e.data?.trigger === TriggerType.AT_END);
            return (
                <NodeWrapper selected={selected} title="Popup Video" icon={Video} colorClass="bg-pink-600" isTerminal={isTerminal}>
                    <Handle type="target" position={Position.Top} className="!bg-pink-500 !w-3 !h-3" />
                    <div className="text-xs text-gray-400">Popup URL</div>
                    <div className="text-sm text-gray-200 truncate font-mono bg-gray-800 p-1.5 rounded border border-gray-700">
                        {data.url || 'No URL configured'}
                    </div>
                    <Handle type="source" position={Position.Bottom} className="!bg-pink-500 !w-3 !h-3" />
                </NodeWrapper>
            );
        });

        const OptionsNode = memo(({ id, data, selected }) => {
            const edges = useEdges();
            const isTerminal = edges.filter((e) => e.source === id).length === 0;
            const isClearNotClear = data.optionType === 'CLEAR_NOT_CLEAR';
            return (
                <NodeWrapper
                    selected={selected}
                    title={`Options (${data.optionType})`}
                    icon={HelpCircle}
                    colorClass="bg-emerald-600"
                    isTerminal={isTerminal}
                >
                    <Handle type="target" position={Position.Top} className="!bg-emerald-500 !w-3 !h-3" />
                    <div className="text-xs text-gray-400 mb-1">Question</div>
                    <div className="text-sm font-medium text-white mb-3">{data.question || 'Define a question...'}</div>
                    <div className="space-y-1">
                        {(data.options || []).map((opt, idx) => (
                            <div
                                key={opt.id}
                                className={`text-[10px] px-2 py-1 rounded flex justify-between items-center ${
                                    !isClearNotClear && data.correctOptionId === opt.id
                                        ? 'bg-emerald-500/20 text-emerald-300 border border-emerald-500/50'
                                        : 'bg-gray-800 text-gray-400 border border-gray-700'
                                }`}
                            >
                                <span>
                                    {String.fromCharCode(65 + idx)}. {opt.text || `Option ${idx + 1}`}
                                </span>
                                {!isClearNotClear && data.correctOptionId === opt.id && <span className="font-bold">âœ“</span>}
                            </div>
                        ))}
                    </div>
                    <Handle type="source" position={Position.Bottom} className="!bg-emerald-500 !w-3 !h-3" />
                </NodeWrapper>
            );
        });

        const ActionNode = memo(({ id, data, selected }) => {
            const edges = useEdges();
            const isTerminal = edges.filter((e) => e.source === id).length === 0;
            return (
                <NodeWrapper selected={selected} title="Action" icon={PlayCircle} colorClass="bg-orange-600" isTerminal={isTerminal}>
                    <Handle type="target" position={Position.Top} className="!bg-orange-500 !w-3 !h-3" />
                    <div className="flex items-center gap-2 text-sm text-gray-200">
                        <Settings2 size={14} className="text-gray-400" />
                        <span>
                            {data.actionType === 'resumePrimary'
                                ? 'Resume Primary'
                                : data.actionType === 'resumePopup'
                                ? 'Resume Popup'
                                : 'Custom'}
                        </span>
                    </div>
                </NodeWrapper>
            );
        });

        // --- Sidebar ---
        const SidebarItem = ({ type, subType, label, icon: Icon, color }) => {
            const onDragStart = (e) => {
                e.dataTransfer.setData('type', type);
                if (subType) e.dataTransfer.setData('subtype', subType);
                e.dataTransfer.effectAllowed = 'move';
            };
            return (
                <div
                    draggable
                    onDragStart={onDragStart}
                    className="flex items-center gap-3 p-3 bg-gray-800 border border-gray-700 rounded-lg cursor-grab hover:border-gray-500 transition-all group"
                >
                    <Icon size={18} className={`text-${color}-500`} />
                    <span className="text-sm font-medium text-gray-200 flex-1">{label}</span>
                    <GripVertical size={14} className="text-gray-600" />
                </div>
            );
        };

        const Sidebar = () => (
            <aside className="w-64 border-r border-gray-800 bg-gray-900 flex flex-col h-full shrink-0">
                <div className="p-4 border-b border-gray-800">
                    <h2 className="text-xs font-bold text-gray-500 uppercase">Components</h2>
                </div>
                <div className="p-4 space-y-6 overflow-y-auto flex-1">
                    <div className="space-y-2">
                        <p className="text-[10px] font-bold text-gray-600 uppercase">Media</p>
                        <SidebarItem type={NodeType.PRIMARY_VIDEO} label="Primary Video" icon={Video} color="indigo" />
                        <SidebarItem type={NodeType.POPUP_VIDEO} label="Popup Video" icon={Video} color="pink" />
                    </div>
                    <div className="space-y-2">
                        <p className="text-[10px] font-bold text-gray-600 uppercase">Interactions</p>
                        <SidebarItem
                            type={NodeType.OPTIONS}
                            subType="CLEAR_NOT_CLEAR"
                            label="Self Assess"
                            icon={CheckCircle}
                            color="emerald"
                        />
                        <SidebarItem type={NodeType.OPTIONS} subType="AB" label="Quiz (A/B)" icon={HelpCircle} color="emerald" />
                        <SidebarItem type={NodeType.OPTIONS} subType="ABC" label="Quiz (A/B/C)" icon={HelpCircle} color="emerald" />
                        <SidebarItem type={NodeType.OPTIONS} subType="ABCD" label="Quiz (A/B/C/D)" icon={HelpCircle} color="emerald" />
                    </div>
                    <div className="space-y-2">
                        <p className="text-[10px] font-bold text-gray-600 uppercase">Flow Controls</p>
                        <SidebarItem type={NodeType.ACTION} label="Resume Node" icon={PlayCircle} color="orange" />
                    </div>
                </div>
            </aside>
        );

        // --- Flow Editor (right side) ---
        const FlowEditor = ({ flowJson, onFlowChange }) => {
            const [nodes, setNodes, onNodesChange] = useNodesState([]);
            const [edges, setEdges, onEdgesChange] = useEdgesState([]);
            const [reactFlowInstance, setReactFlowInstance] = useState(null);
            const [editingNode, setEditingNode] = useState(null);
            const [editingEdge, setEditingEdge] = useState(null);

            const nodeTypes = useMemo(
                () => ({
                    [NodeType.PRIMARY_VIDEO]: PrimaryVideoNode,
                    [NodeType.POPUP_VIDEO]: PopupVideoNode,
                    [NodeType.OPTIONS]: OptionsNode,
                    [NodeType.ACTION]: ActionNode,
                }),
                []
            );

            useEffect(() => {
                if (!flowJson) return;
                const { nodes: initialNodes, edges: initialEdges } = buildGraphFromFlowJson(flowJson);
                nodeId = 1; // reset id counter
                setNodes(initialNodes);
                setEdges(initialEdges);
            }, [flowJson, setNodes, setEdges]);

            useEffect(() => {
                if (!onFlowChange) return;
                const updated = buildFlowJson(nodes, edges, flowJson || {});
                onFlowChange(updated);
            }, [nodes, edges]);

            const onConnect = useCallback(
                (params) => {
                    const newEdge = {
                        ...params,
                        id: `e${params.source}-${params.target}-${Date.now()}`,
                        animated: true,
                        data: { trigger: TriggerType.DEFAULT },
                        label: '',
                    };
                    setEdges((eds) => addEdge(newEdge, eds));
                    setEditingEdge(newEdge);
                },
                [setEdges]
            );

            const onDrop = useCallback(
                (e) => {
                    e.preventDefault();
                    if (!reactFlowInstance) return;
                    const type = e.dataTransfer.getData('type');
                    const subType = e.dataTransfer.getData('subtype');
                    if (!type) return;

                    const position = reactFlowInstance.screenToFlowPosition({ x: e.clientX, y: e.clientY });
                    const newNode = {
                        id: getNextId(),
                        type,
                        position,
                        data: {
                            label: type,
                            ...(type === NodeType.PRIMARY_VIDEO ? { videoType: 'primary' } : {}),
                            ...(type === NodeType.POPUP_VIDEO ? { videoType: 'popup' } : {}),
                            ...(type === NodeType.OPTIONS ? { options: [], optionType: subType } : {}),
                            ...(type === NodeType.ACTION ? { actionType: 'resumePrimary' } : {}),
                        },
                    };
                    setNodes((nds) => nds.concat(newNode));
                    setEditingNode(newNode);
                },
                [reactFlowInstance, setNodes]
            );

            const handleNodeSave = (updated) => {
                setNodes((nds) => nds.map((n) => (n.id === editingNode.id ? { ...n, data: updated } : n)));
                toast.success('Node updated');
            };

            const handleEdgeSave = (updated) => {
                setEdges((eds) => eds.map((e) => (e.id === editingEdge.id ? { ...e, data: updated, label: updated.label } : e)));
                toast.success('Path logic updated');
            };

            const exportFlow = () => {
                const json = buildFlowJson(nodes, edges, flowJson || {});
                const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `flow-designer-${Date.now()}.json`;
                a.click();
                toast.success('JSON Downloaded');
            };

            const handleCopyJson = useCallback(() => {
                try {
                    const json = buildFlowJson(nodes, edges, flowJson || {});
                    const text = JSON.stringify(json, null, 2);
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    textArea.style.top = '0';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        toast.success('Copied to clipboard!');
                    } catch (err) {
                        toast.error('Unable to copy');
                    }
                    document.body.removeChild(textArea);
                } catch (err) {
                    toast.error('Failed to generate JSON');
                }
            }, [nodes, edges, flowJson]);

            return (
                <div className="flex h-full w-full">
                    <Sidebar />
                    <div
                        className="flex-1 relative bg-gray-950"
                        onDrop={onDrop}
                        onDragOver={(e) => e.preventDefault()}
                    >
                        <ReactFlow
                            nodes={nodes}
                            edges={edges}
                            onNodesChange={onNodesChange}
                            onEdgesChange={onEdgesChange}
                            onConnect={onConnect}
                            onInit={setReactFlowInstance}
                            nodeTypes={nodeTypes}
                            onNodeClick={(_, node) => setEditingNode(node)}
                            onEdgeClick={(_, edge) => setEditingEdge(edge)}
                            fitView
                        >
                            <Background color="#1f2937" gap={20} />
                            <Controls />
                            <Panel position="top-right" className="flex gap-2">
                                <button
                                    onClick={() => {
                                        setNodes([]);
                                        setEdges([]);
                                    }}
                                    className="bg-gray-800 hover:bg-red-900/40 p-2 rounded border border-gray-700 text-gray-400 hover:text-red-200 transition-colors"
                                >
                                    <Trash2 size={16} />
                                </button>
                                <button
                                    onClick={handleCopyJson}
                                    className="bg-gray-800 hover:bg-gray-700 px-3 py-2 rounded border border-gray-700 text-xs font-bold flex items-center gap-2"
                                >
                                    <Copy size={14} /> Copy
                                </button>
                                <button
                                    onClick={exportFlow}
                                    className="bg-indigo-600 hover:bg-indigo-500 px-4 py-2 rounded text-xs font-bold flex items-center gap-2 shadow-lg"
                                >
                                    <Download size={14} /> Export
                                </button>
                            </Panel>
                        </ReactFlow>

                        {editingNode?.type?.includes('Video') && (
                            <VideoConfigModal
                                data={editingNode.data}
                                onSave={handleNodeSave}
                                onClose={() => setEditingNode(null)}
                            />
                        )}
                        {editingNode?.type === NodeType.OPTIONS && (
                            <OptionsConfigModal
                                data={editingNode.data}
                                onSave={handleNodeSave}
                                onClose={() => setEditingNode(null)}
                            />
                        )}
                        {editingNode?.type === NodeType.ACTION && (
                            <ActionConfigModal
                                data={editingNode.data}
                                onSave={handleNodeSave}
                                onClose={() => setEditingNode(null)}
                            />
                        )}
                        {editingEdge && (
                            <EdgeConfigModal
                                sourceNode={nodes.find((n) => n.id === editingEdge.source)}
                                data={editingEdge.data}
                                onSave={handleEdgeSave}
                                onClose={() => setEditingEdge(null)}
                            />
                        )}
                    </div>
                </div>
            );
        };

        // --- Node Designer App (JSON + Flow) ---
        const NodeDesignerApp = () => {
            const [loading, setLoading] = useState(true);
            const [jsonText, setJsonText] = useState('');
            const [flowJson, setFlowJson] = useState(null);

            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const parentKey = params.get('key');
                const subtopicId = params.get('id');

                if (!parentKey || !subtopicId) {
                    setLoading(false);
                    return;
                }

                (async () => {
                    try {
                        const docRef = db
                            .collection('subtopics')
                            .doc(parentKey)
                            .collection('subtopiclist')
                            .doc(subtopicId);
                        const doc = await docRef.get();
                        if (doc.exists) {
                            const data = doc.data();
                            setFlowJson(data);
                            setJsonText(JSON.stringify(data, null, 2));
                        } else {
                            setJsonText('// No JSON found for this subtopic yet. Start designing on the right.');
                        }
                    } catch (error) {
                        console.error('Error loading subtopic JSON: ', error);
                        setJsonText('// Error loading JSON for this subtopic.');
                    } finally {
                        setLoading(false);
                    }
                })();
            }, []);

            const handleFlowChange = useCallback((updatedFlow) => {
                setFlowJson(updatedFlow);
                setJsonText(JSON.stringify(updatedFlow, null, 2));
            }, []);

            return (
                <div className="w-screen h-screen flex flex-col overflow-hidden">
                    <header className="h-14 border-b border-gray-800 bg-gray-900 flex items-center px-6 justify-between shrink-0">
                        <div className="flex items-center gap-3">
                            <div className="w-8 h-8 bg-indigo-600 rounded-lg flex items-center justify-center shadow-lg shadow-indigo-500/20">
                                <Video size={18} className="text-white" />
                            </div>
                            <h1 className="text-lg font-bold text-gray-100">Node Designer</h1>
                        </div>
                        <div className="text-[10px] font-mono text-gray-500 uppercase tracking-widest">Studio Engine v1.0</div>
                    </header>
                    <main className="flex-1 overflow-hidden flex">
                        <section className="w-1/2 border-r border-gray-800 bg-gray-950 flex flex-col">
                            <div className="p-3 border-b border-gray-800 flex items-center justify-between">
                                <h2 className="text-xs font-bold text-gray-400 uppercase">Subtopic JSON</h2>
                                {loading && <span className="text-[10px] text-gray-500">Loading...</span>}
                            </div>
                            <textarea
                                className="flex-1 bg-gray-950 text-xs text-gray-200 p-3 font-mono outline-none resize-none"
                                value={jsonText}
                                readOnly
                            />
                        </section>
                        <section className="w-1/2 flex flex-col">
                            <ReactFlowProvider>
                                <FlowEditor flowJson={flowJson} onFlowChange={handleFlowChange} />
                            </ReactFlowProvider>
                        </section>
                    </main>
                    <Toaster
                        position="bottom-right"
                        toastOptions={{
                            style: { background: '#111827', color: '#fff', border: '1px solid #374151' },
                        }}
                    />
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<NodeDesignerApp />);
    </script>
</body>
</html>
